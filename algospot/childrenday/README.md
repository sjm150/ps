### Recall

`n+m`을 넘기지 않는 경우의 처리에서 헤멤

현재 탐색하는 값의 `mod n`에 대해 이미 엔트리가 존재하는 경우,\
즉 `mod n` 값이 동일한 값을 이미 탐색한 경우는 아래의 세가지로 구분할 수 있다

* 나머지가 `m`인 정점을 포함하는 사이클인 경우\
이 경우는 이전에 나머지가 `m`인 값을 탐색했을 때 그 값이 `n+m`보다 작았던 경우로 해당 방향의 탐색을 진행해야 한다.
* 나머지가 `m`인 정점을 포함하지 않는 사이클인 경우\
나머지가 `m`인 값을 만날 가능성이 없으므로 해당 방향 탐색을 중단한다.
* 이전에 탐색한 값, 즉 현재보다 더 작은 값 중에 나머지가 같은 값이 있었던 경우\
현재 탐색하는 값은 prefix가 더 붙어도 반드시 이전에 엔트리를 차지한 값보다 클 수 밖에 없으므로 해당 방향 탐색을 중단한다.

처음에는 막연하게 현재 탐색중인 값의 정보만을 가지고 경우를 구분해서 탐색 진행 유무를 결정하려고 했지만,\
정리해서 보니 불가능해 보임\
그렇다고 사이클에 `m`이 포함되는지 확인하는 것도 오버헤드가 꽤 될듯
